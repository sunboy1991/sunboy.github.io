# Canvas 高级

通过阅读《Canvas 基础篇》想必你已经对于 Canvas 的一些基本概念和知识有所了解，在这一章节，你可以学习到一些相对高级的技巧。

## 贝塞尔曲线路径

如果你熟悉 ps 的话，应该会对 ps 里面的钢笔工具十分了解，无论是抠图还是绘制形状，无论是直线还是曲线，绘制起来十分方便。钢笔工具里面绘制曲线的原理，就是使用了贝塞尔曲线。canvas 支持使用贝塞尔曲线绘制，下图为二次贝塞尔曲线示例：

<iframe src="/Graphical/Canvas/demoes/high/1.html" width="500" height="500" />

核心代码

```javascript
ctx.moveTo(beginX, beginY);
ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
```

一条曲线由三个点控制而成：起始点`(beginX,beginY)`、结束点`(endX,endY)`、控制点`(CtrlX,CtrlY)`。  
起始点和结束点很好理解，就是一条线段的始终。控制点在二次贝塞尔曲线中十分关键，它决定了这条曲线的形状。观察上图，拖动里面的蓝点可以感受一下，控制点是曲线在起点的切线和终点切线的焦点。

## 声明式绘制

canvas 的绘制，是命令式的绘制，就是调用了什么样的绘制 api，canvas 就给你绘制出什么内容出来。这种命令式语法学起来简单，读起来直观，但是当需要绘制一个复杂的场景的时候，命令式的绘制需要就需要用到大量绘制命令，整个程序就变得十分庞大，代码量太大，还是不利于维护。

为了减少代码量，可以对绘制命令进行一些抽象封装，减少重复代码。

```javascript
/**
 * @name 简单路径
 * @param {number[]} points - 路径点集
 */
CanvasRenderingContext2D.prototype.easyPath = function(points) {
	this.moveTo(points[0], points[1]);
	for (let i = 2; i < points.length; i += 2) {
		let x = points[i];
		let y = points[i + 1];
		this.lineTo(x, y);
	}
};
// 旧代码
ctx.beginPath();
ctx.moveTo(0, 0);
ctx.lineTo(1, 0);
ctx.lineTo(1, 1);
ctx.lineTo(0, 1);
ctx.closePath();

//新代码
ctx.beginPath();
ctx.easyPath([0, 0, 1, 0, 1, 1, 0, 1]);
ctx.closePath();
```

当然这还远远不够直观，要直观的话还是需要使用声明式语法来构建场景，我们先忽略掉整个场景具体绘制步骤，先把要绘制的内容写出来：

```javascript
const scance = [
	{
		name: "face",
		children: [
			{
				name: "left-eye"
			},
			{
				name: "right-eye"
			},
			{
				name: "mouth"
			}
		]
	}
];
```

我们准备绘制一个笑脸，整个笑脸由脸蛋、左眼、右眼、嘴巴四个部分组成，然后左眼右眼和嘴巴是包含在脸蛋里面的，浅显易懂。

接下来，想象一下大体的形状，同样在这个结构里面表达出来：

```javascript
var scance = [
	{
		name: "face",
		style: {
			shape: "circle",
			x: 100,
			y: 100,
			w: 200,
			h: 200,
			stroke: "#000",
			fill: "#fff"
		},
		children: [
			{
				name: "left-eye",
				style: {
					shape: "circle",
					x: 40 ,
					y: 50 ,
					w: 20,
					h: 20,
					fill: "#000"
				}
			},
			{
				name: "right-eye",
				style: {
					shape: "circle",
					x: 140,
					y: 50,
					w: 20,
					h: 20,
					fill: "#000"
				}
			},
			{
				name: "mouth",
				style: {
					shape: "path",
					paths: [
						["m", 50, 150],
						["q", 100, 200, 150, 150]
					],
					stroke: "#000"
				}0
			}
		]
	}
];
```

<iframe src="/Graphical/Canvas/demoes/high/2.html" width="500" height="500" />

游戏引擎内部也是采用类似的结构渲染出游戏场景，不同的是，游戏引擎更多的是使用命令式语法去创建这个结构。

声明式的优点在于 UI 布局上十分直观，但是对于具体控制不是很方便。而游戏却需要对于一个物体一个对象进行极致操控，所以游戏引擎选择了命令式语法。

## 像素操作

<iframe src="/Graphical/Canvas/demoes/high/3.html" width="500" height="526" />

canvas 允许 js 直接操作图像的每一个像素，主要是使用`canvasRenderingContext2D.getImageData`和`canvasRenderingContext2D.putImageData`这两个方法。

在基础篇已经有简单介绍过`ImageData`这个对象了，这里不多赘述。通过访问`ImageData.data`属性，我们可以得到每个像素的红、绿、蓝、透明这四个通道：

```javascript
let imageData = ctx.getImageData(0, 0, 10, 10);
for (let i = 0; i < imageData.data.length; i += 4) {
	console.log(imageData.data[i]); //红色通道
	console.log(imageData.data[i + 1]); //绿色通道
	console.log(imageData.data[i + 2]); //蓝色通道
	console.log(imageData.data[i + 3]); //透明通道
}
```

通过修改这四个通道，可以做一些简单的效果，比如灰度：

```javascript
let imageData = ctx.getImageData(0, 0, 10, 10);
for (let i = 0; i < imageData.data.length; i += 4) {
	var gray =
		(imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
	imageData.data[i] = gray;
	imageData.data[i + 1] = gray;
	imageData.data[i + 2] = gray;
}
ctx.putImageData(imageData, 0, 0);
```

获取到当前像素的红绿蓝三原色的值，给他们求一个平均值，然后在赋值回去，这就是灰度的简单计算。最后别忘了将修改过的`ImageData`绘制回 canvas 上。

以像素顺序或许难以确定当前像素对应的位置，也可以以像素位置为顺序获取像素：

```javascript
const width = 10;
const height = 10;
let imageData = ctx.getImageData(0, 0, width, height);
for (let x = 0; x < width; x++) {
	for (let y = 0; y < height; y++) {
		
		//将x、y转化成像素索引i
		let i = y * width + x;

		var gray =
			(imageData.data[i] +
				imageData.data[i + 1] +
				imageData.data[i + 2]) /
			3;
		imageData.data[i] = gray;
		imageData.data[i + 1] = gray;
		imageData.data[i + 2] = gray;
	}
}
ctx.putImageData(imageData, 0, 0);
```
有了位置就可以做一些简单的像素偏移操作，比如上面demo中的扭曲。也可以做一些图像处理，比如使用sobel算子做查找边缘操作，可以通过按`f12`查看这些例子的js源码。

值得注意的是，这些像素操作，都是cpu串行计算的，如果一个canvas图像分辨率非常高，采用像素操作非常容易造成卡顿，因此不建议用于动画中。但如果有业务需要的话，倒是可以用来简单当图像处理使用。

>当然，涉及到像素的话，最好还是了解学习一下webgl，使用gpu并行计算，计算效率更快，且不会引起页面卡顿。

## 简单事件监测

## 高级事件系统

## 局部更新
