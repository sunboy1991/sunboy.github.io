# 简单入门

> 阅读此章节，请确保已经阅读过[GLSL 语言](./GLSL语言.md)，对 GLSL 里面的一些概念、类型、运算符等有大致了解。如果你在阅读的过程中遇到不懂的js API，请使用MDN查询他们的详细内容

[[toc]]
## 获取 webgl 上下文

webgl 上下文（WebglRenderingContext），是浏览器提供给 javascript 使用 webgl 绘图的接口，所有与 webgl 相关的操作都与 webgl 上下文相关。这个对象，只能通过调用`HTMLCanvasElement`的`getContext`方法获得:

### 浏览器端

```javascript
// 创建一个canvas元素
const canvas = document.createElement("canvas");

//获取webgl上下文
const gl = canvas.getContext("webgl");
```

在调用`getContext`方法的时候传入`webgl`或`experimental-webgl`字符串，可以创建 webgl 上下文。

### 微信小程序端

在微信小程序中，同样也可以使用 webgl，而且小程序中的 webgl 上下文中实现的属性、方法与浏览器端完全一致,（但会有部分微信版本存在 bug，比如无法实现透明通道），获取上下文的方式也是一样的：

```html
<!-- canvas.wxml -->
<canvas type="webgl" id="myCanvas"></canvas>
```

```javascript
Page({
	onReady() {
		//创建wxml查询对象
		const query = wx.createSelectorQuery();

		//查询id为"myCanvas"的元素
		query
			.select("#myCanvas")
			.node()
			.exec(res => {
				//获得canvas
				const canvas = res[0].node;

				//获取webgl上下文
				const gl = canvas.getContext("webgl");
			});
	}
});
```

### 微信小游戏端

在微信小游戏里面，因为小游戏整个场景就是一个全屏的`canvas`元素，获取上下文的方法比小程序更方便:

```javascript
//创建一个canvas对象
const canvas = wx.createCanvas();

//获取webgl上下文
const gl = canvas.getContext("webgl");
```

## 绘制第一个图形

从最简单的三角形开始。三个点确定一个面，面是一个模型的基本单位，因此三角形在计算机图形学里面又被称为“图元”。

### webgl绘制流程
webgl 的绘制流程是：

1. 顶点配置：先告诉 webgl 要画多少个顶点，这些顶点的位置分别在什么地方。
1. 图元装配：webgl 拿到顶点之后，根据顶点顺序和划分规则，把顶点连接起来成为一个个面片，形成图元，在这个阶段，webgl 可以使用**顶点着色器**对每个顶点进行编辑，比如给顶点进行位移操作等等；3d 模型的顶点，就是在这个阶段，通过与一个**视图矩阵**相乘，把`[x,y,z]`三维坐标映射到画布里面的`[x,y]`二维坐标。
1. 光栅化：经过上一个流程图元装配后，webgl 知道了每个图元所围住的每个像素，而光栅化，则是给每个像素指定一个颜色，即确定像素的 RGB 值。在这个阶段，webgl 使用**片元着色器**设置像素的 RGB 值。

所以我们绘制一个简单的三角形，就需要告诉 webgl 三个点，还需要一个顶点着色器确认/修改点的位置、一个片元着色器给三角形上色。看起来很麻烦，不过不用灰心，跟着步骤慢慢来，你会体验到 webgl 的强大之处。

### 着色器代码
先写下顶点着色器和片元着色器吧，这个比较简单：  
顶点着色器:

```glsl
attribute vec2 a_Position;
void main(){
    gl_Position = vec4(a_Position,0.,1.);
}
```

这段代码很简单，就是接受一个`attribute`修饰符的二维矢量类型（`vec2`）变量`a_Position`，`a_Position`存放的是顶点的坐标值，我们把这个坐标值告诉 webgl，也就是`gl_Position`，注意，glsl 语言是强类型语言，`gl_Position`的类型是四维矢量（`vec4`），所以我们使用`vec4`这个构造函数构造一个四维矢量类型的变量赋值给`gl_Position`

片元着色器：

```glsl
void main(){
    gl_FragColor = vec4(1.,0.,0.,1.);
}
```

这段代码更简单了，就是让 webgl 给三角形涂上红色。注意，glsl 中，当四维矢量表示一个颜色时，一维至四维分别代表：红色通道、绿色通道、蓝色通道、alpha 通道。范围值在'0.0~1.0'之间。

### js代码
然后，我们开始 js 部分的编写：
首先，我们创建一个 canvas 元素，再获取 webgl 上下文：

```js
const canvas = document.createElement("canvas");
const gl = canvas.getContext("webgl");
canvas.width = 500;
canvas.height = 500;
canvas.style.background = "#000";
document.body.appendChild(canvas);
```

接下来，创建着色器程序，把上面写的两个着色器源码放到浏览器里面编译一下，然后接入着色器程序里面：

```js
//创建着色器程序
const program = gl.createProgram();

//创建顶点着色器对象
const vtxShader = gl.createShader(gl.VERTEX_SHADER);

//创建片元着色器对象
const fgmShader = gl.createShader(gl.FRAGMENT_SHADER);

//给着色器对象写入代码
gl.shaderSource(
	vtxShader,
	`attribute vec2 a_Position;
    void main(){
        gl_Position = vec4(a_Position,0.,1.);
    }`
);

//编译着色器
gl.compileShader(vtxShader);

//把着色器对象绑定到着色器程序上
gl.attachShader(program, vtxShader);


//接下来步骤同上
gl.shaderSource(
	fgmShader,
	`void main(){
        gl_FragColor = vec4(1.,0.,0.,1.);
    }`
);
gl.compileShader(fgmShader);
gl.attachShader(program, fgmShader);

//链接着色器程序，即把顶点着色器和片元着色器关联起来
gl.linkProgram(program);
```

可以看到无论是顶点着色器，还是片元着色器，创建方式都是相同的，都是**创建着色器对象 -> 写入着色器源码 -> 编译着色器源码 -> 接入着色器程序**，最后两个着色器都接入到着色器程序里面之后，调用`gl.linkProgram`方法把这两个着色器给关联起来。

接下来，创建一个 webgl 的缓存和一个顶点集合，并且告知 webgl 使用这个缓存，最后把顶点集合写进缓存里面：

```js
const pointBuf = gl.createBuffer();
const points = new Float32Array([0, 0, 1, 0, 0, 1]);
gl.bindBuffer(gl.ARRAY_BUFFER, pointBuf);
gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
```

这里的顶点集合设置了三个点：`(0,0) (1,0) (0,1)`，通过上面的操作，这三个点六个值是写入到 webgl 的缓存里面去了，但 webgl 并不知道要如何使用它们，所以接下来我们要告诉 webgl 如何读取这个缓存：

```js
const aPositionIdx = gl.getAttribLocation(program, "a_Position");
gl.enableVertexAttribArray(aPositionIdx);
gl.vertexAttribPointer(aPositionIdx, 2, gl.FLOAT, false, 0, 0);
```

代码里，先通过`gl.getAttribLocation(program,'a_Position')`获取到着色器程序里面变量名为`a_Position`的内存地址（类似指针），然后`gl.enableVertexAttribArray(aPositionIdx)`允许为`aPositionIdx`分配顶点数组。最后`gl.vertexAttribPointer(aPositionIdx,2,gl.FLOAT,false,0,0)`设置顶点数组的分配规则：

-   每次读取数组里面**2**个值作为一个顶点，
-   将这两个值解析成**float**浮点类型，
-   **不**需要将这两个值归一化（即计算成 0~1 之间的值），
-   从数组第 **0** 位开始读取，
-   跳过 **0** 位后读取下一个顶点的值。

最后，调用着色器程序绘制代码：
```javascript
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3);
```

### 完整代码
完整代码如下所示：
<!-- <open-iframe-btn src="/Graphical/WebGL/demos/start/1.html" width=320 height=320 /> -->
```js
const canvas = document.createElement("canvas");
canvas.width = 300;
canvas.height = 300;
canvas.style.background = "#000";
document.body.appendChild(canvas);
const gl = canvas.getContext("webgl");
const program = gl.createProgram();
const vtxShader = gl.createShader(gl.VERTEX_SHADER);
const fgmShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(
	vtxShader,
	`attribute vec2 a_Position;
    void main(){
        gl_Position = vec4(a_Position,0.,1.);
    }`
);
gl.compileShader(vtxShader);
gl.attachShader(program, vtxShader);
gl.shaderSource(
	fgmShader,
	`void main(){
        gl_FragColor = vec4(1.,0.,0.,1.);
    }`
);
gl.compileShader(fgmShader);
gl.attachShader(program, fgmShader);
gl.linkProgram(program);
const aPositionIdx = gl.getAttribLocation(program, "a_Position");
const pointBuf = gl.createBuffer();
const points = new Float32Array([0, 0, 1, 0, 0, 1]);
gl.bindBuffer(gl.ARRAY_BUFFER, pointBuf);
gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
gl.enableVertexAttribArray(aPositionIdx);
gl.vertexAttribPointer(aPositionIdx, 2, gl.FLOAT, false, 0, 0);
gl.useProgram(program);
gl.drawArrays(gl.TRIANGLES, 0, 3);
```

## js 与着色器程序交互

### 修改源码
最简单的交互，莫过于直接用js修改着色器源码了，它是以字符串的形式由js调用编译函数才进行编译，所以js可以通过字符串操作对着色器源码做一些“预编译”操作。但是要注意，修改源码然后频繁执行编译是十分耗性能的事情，容易引起内存泄漏。所以改动只能改一次，就是在编译前针对特定场景改动一些特定的代码而已，一个着色器编译后就不需要重新编译了。

### 修改缓存
上文的代码洋洋洒洒写了一大堆，但实际上核心就是把数据写入缓存，然后由着色器程序执行。而着色器程序是跑在gpu里面的。为了高效地从cpu传递数据到gpu，所以js需要使用类型数组，将数据直接类型格式化后写入底层cpu内存里面。

利用这个特点，我们可以让js直接修改缓存的数据，然后再让webgl执行即可，举个例子，让三角形某个顶点跟随鼠标移动：
```js
//接上文代码
canvas.onmousemove=(e)=>{
    //把数据归一化（计算成0~1的范围内）
    let x = e.offsetX/canvas.width;
    let y = e.offsetY/canvas.height;

    //由上文运行结果可知，(0,0)是中心点，左端点是(-1,0)，右端点是(1,0)
    points[4]=x*2-1;

    //由上文运行结果可知，(0,0)是中心点，上端点是(0,1)，下端点是(0,-1)
    points[5]=1-y*2

    //重新写入缓存
    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}
```
<!-- 点击运行可以查看效果：<open-iframe-btn src="/Graphical/WebGL/demos/start/2.html" width=360 height=380 /> -->

### 使用attribute变量修改
现在，我们已经能够让三角形某个顶点跟随鼠标移动了，那么反过来让我们来写个小游戏：不要让三角形任意一个顶点碰到鼠标！  
这非常简单啊，按照上面的例子，只需要拿到鼠标的位置，然后再遍历一下`points`数组，发现有跟鼠标位置重合的坐标就改一下，最后修改下缓存就大功告成了。  
这样当然没问题，那如果有两个三角形、三个三角形、四个三角形乃至成千上万个三角形呢，如果用上面的办法，使用js遍历显然十分吃力了。  

webgl有什么好办法吗？当然有！webgl绘制流程中第二个流程：图元装配，这个流程可以用着色器更改顶点位置！而且这个运算是在gpu里面完成的，不会阻塞js进程！  
所以要做的事情很简单了：
1. 告诉webgl鼠标位置
1. 用顶点着色器让顶点避开鼠标位置

还是先从着色器代码入手：
```glsl
attribute vec2 a_Position;
attribute vec2 a_Mouse;
void main(){
    vec2 pos = a_Position;
    float len = distance(a_Position,a_Mouse);
    if(len<0.5){
        pos-=normalize(a_Mouse-a_Position)*(0.5+0.5*len);
    }
    gl_Position = vec4(pos,0.,1.);
}
```
首先添加了一个新的attribute类型二维矢量变量`a_Mouse`，用来接收鼠标的位置。然后这里出现了两个新函数，`distance`和`normalize`，`distance`获取的是两个向量之间的距离，也就是两个点之间的距离；`normalize`获取的是某个向量的单位向量。  

因为attribute类型的变量不能修改，所以我们新声明了一个变量`pos`，把`a_Position`的值传给它。然后计算一下当前顶点与鼠标的距离，判断一下，如果这个距离小于图片的四分之一的话，就让`pos`往反方向偏移一段距离。最后把新顶点赋值给`gl_Position`，也就是告诉webgl这个点的位置。

然后再看看js部分：
```js
const aMouseIdx = gl.getAttribLocation(program,'a_Mouse');
gl.vertexAttrib2f(aMouseIdx,0,0);
canvas.onmousemove=(e)=>{
    let x = e.offsetX/canvas.width;
    let y = e.offsetY/canvas.height;
    gl.vertexAttrib2f(aMouseIdx,x*2-1,1-y*2);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}
```
因为顶点着色器里面新增了一个变量，所以先拿到它的内存地址，然后用`gl.vertexAttrib2f`直接给它赋值。
点击运行可以查看效果：
<!-- <open-iframe-btn src="/Graphical/WebGL/demos/start/3.html" width=316 height=347 /> -->
非常简单！而且效果非常流畅！

### 使用varying传递变量
但是如果我们要更进一步，想让靠近鼠标的地方显示不同的颜色，该怎么做呢？  
回顾上面的例子，我们是通过片元着色器给三角形上色的。所以一样的，把鼠标位置传进片元着色器就可以了。

那也是在片元着色器里面声明一个`attribute a_Mouse`？  
不不不，`attribute`只能在顶点着色器内使用，如果我们顶点着色器和片元着色器里面都需要使用这个变量，可以使用`varying`修饰符，将变量值从顶点着色器传递到片元着色器：
```glsl
//顶点着色器
attribute vec2 a_Position;
attribute vec2 a_Mouse;
varing vec2 v_Mouse;
void main(){
    vec2 pos = a_Position;
    float len = distance(a_Position,a_Mouse);
    if(len<0.5){
        pos-=normalize(a_Mouse-a_Position)*(0.5+0.5*len);
    }
    v_Mouse = a_Mouse
    gl_Position = vec4(pos,0.,1.);
}

//片元着色器
varying vec2 v_Mouse;
void main(){
    gl_FragColor = vec4(1.,v_Mouse,1.);
}
```

### 使用uniform传递变量
一般来说，`varying`修饰符适合传递经过顶点着色器修改后的值。像上面的例子，鼠标的坐标没有经过任何修改就传递出去了，换句话说，就是顶点着色器和片元着色器共用一份同样的数据，那这样的数据，其实没必要使用`attribute + varying`两个修饰符的组合让两个着色器共享变量的。

我们可以使用`uniform`修饰符：
```javascript
const uMouseIdx = gl.getUniformLocation(program,'u_Mouse');
gl.uniform2f(uMouseIdx,0,0);
canvas.onmousemove=(e)=>{
    let x = e.offsetX/canvas.width;
    let y = e.offsetY/canvas.height;
    gl.uniform2f(uMouseIdx,x*2-1,1-y*2);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}
```
与attribute类似，同样是获得变量地址，然后赋值的操作。然后再看看着色器代码：
```glsl
//顶点着色器
attribute vec2 a_Position;
uniform vec2 u_Mouse;
varying float v_len;
void main(){
    vec2 pos = a_Position;
    float len = distance(a_Position,u_Mouse);
    v_len=len;
    if(len<0.5){
        pos-=normalize(u_Mouse-a_Position)*(0.5+0.5*len);
    }
    gl_Position = vec4(pos,0.,1.);
}

//片元着色器
uniform vec2 u_Mouse;
varying float v_len;
void main(){
    gl_FragColor = vec4(v_len,u_Mouse,1.);
}
```
上面着色器中，都直接使用了`uniform`修饰的变量进行计算，并且演示了`varying`修饰符真正的作用，即获取顶点坐标与鼠标位置的距离，然后传递给片元着色器当做它的红色通道。而绿色通道与蓝色通道，则分别使用鼠标坐标的x、y值。

## 使用纹理


## 像素运算

## 矩阵

## 3D 成像
