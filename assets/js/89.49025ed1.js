(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{544:function(n,a,t){"use strict";t.r(a);var e=t(27),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"如何更好的封装api模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何更好的封装api模块"}},[n._v("#")]),n._v(" 如何更好的封装api模块")]),n._v(" "),t("blockquote",[t("p",[n._v("api模块是我们与后台进行通信的一种方式，其方式有多种，比如引入  vue-resource/vue-axios模块，或者是直接使用jqueryAjax，或者是使用我们内部封装的[Api.js]")])]),n._v(" "),t("p",[n._v("对于如此众多的通信方式，如何选择或者是更好维护项目是个问题，对此，我们进行api的二次封装：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("..src/\n├── api                         \n│   ├── config.js                     \n│   ├── index.js                    \n│   └── starting.js    \n├── App.vue\n└── main.js\n")])])]),t("p",[n._v("config.js")]),n._v(" "),t("p",[n._v("将有关domain的配置统一管理，通过window.ENV（通过webpack进行配置得到的环境变量）进行环境判断，方便后续维护")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const API_CONFIG = {\n  dev: {\n    API_URL: '//localhost',\n    API_LOG: '//localhost',\n  },\n\n}\n\nlet {\n  API_URL,\n  API_LOG\n} = API_CONFIG[window.EVN];\n\nexport {\n  API_URL,\n  API_LOG\n}\n")])])]),t("p",[n._v("starting.js")]),n._v(" "),t("p",[n._v("这里主要是将后台接口统一在文件中，按模块区分，可以多个文件，页面按需引入模块的接口就行了")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('export default {\n    ////////后台接口/////////\n    init: "init?ct=gxj_starting&ac=init",    //首发页面初始化\n    draw: "draw?ct=gxj_starting&ac=draw",    //抽奖接口\n    //....\n}\n')])])]),t("p",[n._v("index.js")]),n._v(" "),t("p",[n._v("无论是使用Api.js或者是jqueryAjax等进行通信，都将其进行二次封装")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//引入api配置\nimport { API_URL } from '/api/config'; \n//引入通信工具\nimport Api from '/lib/Api';\n\n//通用配置\nApi.config({\n  dataType: 'jsonp',\n  domain: API_URL,\n  urlModel: 1\n});\n\n//二次封装api，这里可以实现拦截，重定向的功能\nconst jsonp = (url, p) => {\n    return new Promise((resolve, reject) => {\n        //...Api.require\n        //...$.ajax\n    });\n}\n\nexport default {\n  jsonp\n}\n")])])]),t("p",[n._v("main.js")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from \"vue\";\n\n//添加-通信接口\nimport http from '/api';\nVue.prototype.$http = http;\n")])])]),t("p",[n._v("App.vue")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import $api from "api/starting";\n\nexport default {\n    created() {\n        this.$http.jsonp($api.init, params).then(res => {\n          //...\n        });\n    }\n}\n')])])]),t("p",[n._v("之所以要将api接口封装，主要原因还是为了对api接口进行外观统一，无论内部是使用何种通信方式，对使用者来说，其接口的调用方式都是一致，不需要理会内部的修改。")])])}),[],!1,null,null,null);a.default=s.exports}}]);