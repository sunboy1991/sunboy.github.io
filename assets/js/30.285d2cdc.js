(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{477:function(e,t,o){"use strict";o.r(t);var n=o(27),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_3d-force-touch-的新玩儿法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3d-force-touch-的新玩儿法"}},[e._v("#")]),e._v(" 3D Force Touch 的新玩儿法")]),e._v(" "),o("p",[e._v("几天前我买了部 iPhone 6S，接着我被 "),o("strong",[e._v("3D touch")]),e._v(" 功能深深地吸引住了，于是迫不及待地体验了一番。")]),e._v(" "),o("iframe",{attrs:{width:"382",height:"214",src:"https://www.youtube.com/embed/d-hlQISXj8M",frameborder:"0",allowfullscreen:""}}),e._v(" "),o("p",[e._v("在一个应用程序中，Peek 和 pop 是一个很出彩的特性。不过话说回来：我们没有太多的控制权。我们只能添加一个预览功能和几个动作 - iOS 系统会管理剩下的工作。")]),e._v(" "),o("p",[e._v("因为我探索了 "),o("em",[e._v("3D Touch")]),e._v(" 功能，就一直在思考与内容互动的新方式。Peek 和 pop 是一个很好的交互方式; 但我真正想要的是创建自定义的控制技术。")]),e._v(" "),o("p",[e._v("我们需要考虑的是，由于 "),o("em",[e._v("3D touch")]),e._v(" 仅在 iPhone 6S 和 6S Plus 上提供，所以不应该存在"),o("strong",[e._v("仅")]),e._v("能使用该动作执行的功能。用户应不依赖 "),o("em",[e._v("3D touch")]),e._v(" 也可以完成所有功能（就像使用 Peek 和 pop 实现的一样）, 而 "),o("em",[e._v("3D touch")]),e._v(" 最好只提供额外的交互体验。")]),e._v(" "),o("h4",{attrs:{id:"访问-force-属性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#访问-force-属性"}},[e._v("#")]),e._v(" 访问 force 属性")]),e._v(" "),o("p",[e._v("新的 force 属性在 UITouch 类中。如果想获得用户 "),o("em",[e._v("touch")]),e._v(" 事件，我们应该重写 "),o("em",[e._v("touches")]),e._v(" 相关方法（类如：touchesBegan, touchesMoved, touchesEnded）, 或者继承相关类（例如 UIView，UIButton；见例1），抑或继承实现一个手势（见下文，例 2 和 例 3）；")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("import UIKit.UIGestureRecognizerSubclass\n\nclass ForceGestureRecognizer: UIGestureRecognizer {\n\n    var forceValue: CGFloat = 0\n\n    override func touchesBegan(touches: Set, withEvent event: UIEvent) {\n        super.touchesBegan(touches, withEvent: event)\n        state = .Began\n        handleForceWithTouches(touches)\n    }\n\n    override func touchesMoved(touches: Set, withEvent event: UIEvent) {\n        super.touchesMoved(touches, withEvent: event)\n        state = .Changed\n        handleForceWithTouches(touches)\n    }\n\n    override func touchesEnded(touches: Set, withEvent event: UIEvent) {\n        super.touchesEnded(touches, withEvent: event)\n        state = .Ended\n        handleForceWithTouches(touches)\n    }\n\n    func handleForceWithTouches(touches: Set) {\n        if touches.count != 1 {\n            state = .Failed\n            return\n        }\n        guard let touch = touches.first else {\n            state = .Failed\n            return\n        }\n        forceValue = touch.force\n    }\n}\n")])])]),o("p",[e._v("在这里，我们可以看到 force 属性值介于 0.0 ~ 6.667 之间；关于该值的更多讨论，推荐看这篇文章"),o("a",{attrs:{href:"https://medium.com/@rknla/exploring-apple-s-3d-touch-f5980ef45af5",target:"_blank",rel:"noopener noreferrer"}},[e._v("探索 Apple`s 3D Touch"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("h4",{attrs:{id:"例-1-force-button"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#例-1-force-button"}},[e._v("#")]),e._v(" 例 1: Force Button")]),e._v(" "),o("p",[o("strong",[e._v("Force Button")]),e._v(" 是 UIButton 的子类，可根据按压的力量变化来修改按钮的阴影属性（见文章开头处视频）。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("func shadowWithAmount(amount: CGFloat) {\n    self.layer.shadowColor = shadowColor.CGColor\n    self.layer.shadowOpacity = shadowOpacity\n    let widthFactor = maxShadowOffset.width/maxForceValue\n    let heightFactor = maxShadowOffset.height/maxForceValue\n    self.layer.shadowOffset = CGSize(width: maxShadowOffset.width - amount * widthFactor, height: maxShadowOffset.height - amount * heightFactor)\n    self.layer.shadowRadius = maxShadowRadius - amount\n}\n")])])]),o("p",[e._v("上面的函数依据按压力的大小来修改按钮的阴影。你可以找到另外一个例子，解释了如何依据按压力的大小来缩放按钮，[文章在这里]（https://github.com/Produkt/3dForceTouchExamples）。")]),e._v(" "),o("p",[e._v("这个按钮使用 "),o("em",[e._v("3D touch")]),e._v(" 技术只实现了视觉上的反馈，它没有任何额外的功能。其实，它可以在用户用力按压按钮时系统回调的事件（如 _UIControlEvents.ForceMaxInside）中进行我们自己额外的事件响应。")]),e._v(" "),o("h4",{attrs:{id:"example-2-zooming"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#example-2-zooming"}},[e._v("#")]),e._v(" Example 2: Zooming")]),e._v(" "),o("iframe",{attrs:{width:"382",height:"214",src:"https://www.youtube.com/embed/8RcDqH4kfo8",frameborder:"0",allowfullscreen:""}}),e._v(" "),o("p",[e._v("我们都是用来双指的捏来实现放大和缩小，这样操作起来感觉自然。然而，有时候当你单手拿着手机时，双指缩放手势操作起来会感觉怪怪的。谷歌地图应用程序尝试通过使用 "),o("em",[e._v("doble-tap-longPress-drag")]),e._v(" 手势来解决这个的问题（这感觉怪怪的，如果你不使用它）。")]),e._v(" "),o("p",[e._v("当使用 ForceGestureRecognizer 手势时（见上面的代码），该手势在你拖拽时也很容易放大和缩小。如果你有一个 iPhone6S 可以试一试，这感觉太棒了。")]),e._v(" "),o("p",[e._v("为了达到这个效果，我简单地应用一个 CATransform3D 缩放效果到 ImageView 的层。这样，图像从它的中心进行缩放。通过按住并移动我的手指（缩小到一个特定的区域），我就可以根据手指的位置更新图片的锚点。")]),e._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",[o("code",[e._v("func imagePressed(sender: ForceGestureRecognizer) {\n    let point = sender.locationInView(self.view)\n    let imageCoordPoint = CGPointMake(point.x - initialFrame.origin.x, point.y - initialFrame.origin.y)\n\n    var xValue = max(0, imageCoordPoint.x / initialFrame.size.width)\n    var yValue = max(0, imageCoordPoint.y / initialFrame.size.height)\n\n    xValue = min(xValue, 1)\n    yValue = min(yValue, 1)\n\n    let anchor = CGPointMake(xValue, yValue)\n    mainImageView.layer.anchorPoint = anchor\n    let forceValue = max(1, sender.forceValue)\n    mainImageView.layer.transform = CATransform3DMakeScale(forceValue, forceValue, 1)\n\n    if sender.state == .Ended {\n        mainImageView.layer.anchorPoint = CGPointMake(0.5, 0.5)\n        mainImageView.layer.transform = CATransform3DIdentity\n    }\n}\n")])])]),o("p",[e._v("最后一个关于 "),o("em",[e._v("3D_touch")]),e._v(" 的交互特性我觉得就是"),o("strong",[e._v("控制动画")]),e._v("了.不过，实话说，我还没有发现这种相互作用的任何有趣的用途（不是作为精细调谐），但我想提一提它（有人可能会发现它很有用）。")]),e._v(" "),o("p",[e._v("这里有一个动画视频是由 "),o("em",[e._v("3D_touch")]),e._v(" 进行的控制。")]),e._v(" "),o("iframe",{attrs:{width:"382",height:"214",src:"https://www.youtube.com/embed/LXQ-iSYhHFI",frameborder:"0",allowfullscreen:""}}),e._v(" "),o("p",[e._v("这里还有给设计师和工程师的一些示例演示了使用 "),o("em",[e._v("3D_touch")]),e._v(" 进行交互的方法。我希望我已经说服你去尝试 "),o("em",[e._v("3D_touch")]),e._v("。")]),e._v(" "),o("p",[e._v("我想通过推荐[FlexMonkey 的博客]（http://flexmonkey.blogspot.com.es）最新文章：[3D Retouch]（http://flexmonkey.blogspot.com.es/2015/10/3D-retouch-experimental-retouching-app.html），在这篇文章中，他使用 3D Touch 修改滤镜的强度。")]),e._v(" "),o("p",[e._v("整个项目在这里[github]（https://github.com/Produkt/3dForceTouchExamples）。")]),e._v(" "),o("p",[o("em",[e._v("特别感谢 @pivalue")])])])}),[],!1,null,null,null);t.default=a.exports}}]);