(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{548:function(t,n,e){"use strict";e.r(n);var a=e(27),l=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"组件之间的通信机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件之间的通信机制"}},[t._v("#")]),t._v(" 组件之间的通信机制")]),t._v(" "),e("blockquote",[e("p",[t._v("对于vue框架来说，最常见的就是组件了，而组件间的通信也是必不可少的，所以此章节主要讲述组件间通信的实现方式。")])]),t._v(" "),e("h3",{attrs:{id:"父子组件通信机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父子组件通信机制"}},[t._v("#")]),t._v(" 父子组件通信机制")]),t._v(" "),e("p",[t._v("父子组件通信机制主要分为两种，")]),t._v(" "),e("ol",[e("li",[t._v("父组件传递数据给子组件")]),t._v(" "),e("li",[t._v("子组件传递数据给父组件")])]),t._v(" "),e("p",[t._v("对于父组件传递数据给子组件，常见方法是props")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//父组件\n<child :text=\"text\"></child>\n\n//子组件\nexport default {\n    props: {\n        text: { \n            type: String, \n            default: '' \n        }\n    }\n}\n")])])]),e("p",[t._v("而对于子组件传递数据给父组件，方式有：")]),t._v(" "),e("ol",[e("li",[t._v("回调传参：既父组件将回调方法作为参数传递给子组件，子组件再进行回调")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('//父组件\n<child :handleChange="handleChange"></child>\nexport default {\n    methods: {\n        handleChange(value) {\n            ///...\n        }\n    },\n}\n\n//子组件\n<button @click="handleChange(\'value\')">click</button>\nexport default {\n    props: {\n        handleChange: { \n            type: Function, \n            default: _ => {}\n        }\n    }\n}\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("自定义事件：子组件通过事件通知父组件")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//父组件\n<child @childChange=\"handleChange\"></child>\nexport default {\n    methods: {\n        handleChange(value) {\n            ///...\n        }\n    },\n}\n\n//子组件\n<button @click=\"$emit('childChange', 'value')\">click</button>\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("定义ref：父组件通过给子组件定义ref属性，直接通过"),e("code",[t._v("vm.$refs.[子组件的ref].[子组件的属性]")]),t._v("获取子组件的数据")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//父组件\n<child ref=\"child\"></child>\nexport default {\n    methods: {\n        getChildData() {\n            return this.$refs.child.text;\n        }\n    }\n}\n\n//子组件\nexport default {\n    data () {\n        return {\n            text: 'text'\n        }\n    }\n}\n")])])]),e("p",[t._v("除了以上两种之外，我们可能需要对父子组件进行双向绑定，这里我们使用 "),e("code",[t._v(".sync")]),t._v(" 修饰符")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//父组件\n<child :word.sync=\"text\"></child>\nexport default {\n    data() {\n        return{\n            text: ''\n        }\n    }\n}\n\n//子组件\n<input type=\"text\" v-model=\"text\">\nexport default {\n    data() {\n        return {\n            text: '',\n        }\n    },\n    props: {\n        word: { \n            type: String, \n            default: '' \n        }\n    }\n    watch: {\n        text: function(newValue, oldValue) {\n            //每当text的值改变则发送事件update:word , 并且把值传过去\n            this.$emit('update:word', newValue)\n        }\n    }\n}\n")])])]),e("p",[t._v("其实 "),e("code",[t._v(".sync")]),t._v(" 修饰符是作为一个编译时的语法糖，会被自动扩展成一个 "),e("code",[t._v("v-on")]),t._v(" 监听器：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<child :word.sync="text"></child>\n=> \n<child :word="text" @update:word="val => text = val"></child>\n')])])]),e("p",[t._v("这种方法跟使用自定义事件监听其实是一个道理，只是更加简便，且两者数据是等价的，而非作为参数进行处理。")]),t._v(" "),e("h3",{attrs:{id:"非父子组件通信机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非父子组件通信机制"}},[t._v("#")]),t._v(" 非父子组件通信机制")]),t._v(" "),e("p",[t._v("非父子组件通信机制主要分为两种，")]),t._v(" "),e("ol",[e("li",[t._v("存在共同祖先的通信机制")]),t._v(" "),e("li",[t._v("通过Vuex进行状态管理")])]),t._v(" "),e("p",[t._v("对于存在共同祖先的组件，可以通过共同祖先作为媒介进行传递数据，当然如果层次差异太大或者无法使用中间媒介进行传递数据，则可以使用Vuex进行状态管理。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("发布/订阅模式")])]),t._v(" "),e("p",[t._v("使用Vue的 "),e("code",[t._v("$emit")]),t._v(" 和 "),e("code",[t._v("$on")]),t._v(" 的方法进行通信，如")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("window.vueBus = new Vue();\n\n// 触发组件 A 中的事件  \nvueBus.$emit('child:change', 1);\n\n// 在组件 B 创建的钩子中监听事件  \nvueBus.$on('child:change', id => {  \n    //...  \n})\n")])])]),e("p",[t._v("或者引用外部的媒介，如PubSub：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('//组件A 订阅事件\nPubSub.subscribe("close", (event, data) => {\n    this.close();\n});\n\n//组件B 发布事件\nPubSub.publish("close", "");\n')])])]),e("p",[t._v("的确，使用发布/订阅模式进行组件间的通信是极其方便的，但是有一点需要注意的是，无论是全局事件或者是分布式事件，这两者都是挂载在全局对象，在页面销毁时，需要将其注册的事件也一同销毁，否者可能将造成内存泄露等问题。")])])}),[],!1,null,null,null);n.default=l.exports}}]);